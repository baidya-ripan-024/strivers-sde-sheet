# [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)


| Difficulty    | Topics            | Video                                                  |
| --------------| ------------------| ------------------------------------------------------ |
| **Medium**    | String            | [Video](https://youtu.be/wiGpQwVHdE0?si=41Q37puME7Ropavj) |
|               | Hash Table        | [Article](https://www.geeksforgeeks.org/length-of-the-longest-substring-without-repeating-characters/)


## Description

Given a string `s`, find the length of the longest substring without repeating characters.

```
Example 1:

Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
Example 2:

Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
Example 3:

Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

**Constraints:**

- `0 <= s.length <= 5 * 10^4`
- `s` consists of English letters, digits, symbols, and spaces.


## 1. [Naive Approach] Substrings Starting From Every Index – O(n ^ 2) Time and O(n) Space

### Intution
The problem asks us to find the maximum length of a substring (contiguous characters) such that no character repeats.

To solve this, we can use a brute-force approach by considering every possible starting point of the substring and expanding it until we encounter a duplicate character.

### Approach

1. Start with a variable `ans = 0` to store the maximum length found so far.
2. Loop through each character in the string as the starting point i.
3. For each starting point i, use a HashSet to keep track of characters in the current substring (to detect duplicates).
4. From i, extend the end of the substring j until:
    - We reach the end of the string, or
    - A duplicate character is found (i.e., already exists in the HashSet)
5. When a duplicate is found, break the inner loop.
6. Update ans with the maximum size of the current set (i.e., length of substring without duplicates).
7. After checking all substrings starting at each position, return ans. 

### Code
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        int ans = 0;

        for(int i = 0; i < n; i ++){
            // set to avoid duplicates
            HashSet<Character> set = new HashSet<>();
            for(int j = i; j < n; j ++){
                // when set doesn't contain duplicates 
                if(!set.contains(s.charAt(j))){
                    set.add(s.charAt(j));
                } else {
                    // when duplicate found
                    break;
                }
            }
            // update the ans
            ans = Math.max(ans, set.size());
        }

        return ans;
    }
}
```
### Complexity Analysis :

- **Time Complexity**: `O(n*26)`, the outer loop runs O(n) time, and the inner loop runs in O(26) in the worst case (considering all unique characters), resulting in a total time complexity of O(n*26).
  
- **Auxilary Space**: `O(1)`, vis array has size 26 which is constant.



## 2. [Expected Approach 1]  Using Last Index of Each Character – O(n) Time and O(1) Space

### Intuition:
To find the length of the longest substring without repeating characters, we use a sliding window approach. We maintain a window (using two pointers, `back` and `front`) that expands and contracts to ensure all characters within it are unique.

### Approach:
1. Use a **HashSet** to track unique characters in the current window.
2. Use two pointers, `back` and `front`, to represent the window boundaries.
3. Move the `front` pointer forward, adding characters to the HashSet.
4. If a duplicate character is found, move the `back` pointer forward, removing characters from the HashSet until the duplicate is removed.
5. Keep track of the maximum window size (`longest`) during the process.

### **Code**
``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length() == 0 || s == null) return 0;

        HashSet<Character> st = new HashSet<>();
        int back = 0;
        int longest = 0, count = 0;

        for(int front = 0; front < s.length(); front ++){
            char curChar = s.charAt(front);

            while(st.contains(curChar)){
                st.remove(s.charAt(back ++)); // Start removing character from the first
                count --; 
            }

            st.add(curChar);
            count ++;

            longest = Math.max(longest, count);
        }       
        return longest;
    }
}
```
### Complexity Analysis :
- **Time Complexity**: `O(n) + O(n)`
- **Space Complexity**: `O(n)`
